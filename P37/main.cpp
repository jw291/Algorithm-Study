#include <iostream>
//스스로해결
int main() {
    // 첫 번째줄
    // S:캐시 메모리 Size ( 3<=S<=10)
    // N:작업의 개수 ( 5<=N<=1000)
    
    // 두 번째줄
    // N개의 작업번호
    
    // 배열로 봤을 때, 이전 인덱스(캐시로 따지면 새로 들어온 작업)
    // 일단 벡터로 N만큼 입력할 수 있게하고
    // 나중에 출력을 S만큼 하자.
    // 벡터에 넣은다음에 정렬을 하는 방식인 것 같다.
    // 근데 이럼 캐시의 의미가 없는데 애매하네
    
    // 아니다 배열 5개가 맞는거 같다.
    // 새로운 값이 들어왔을 때 이 값이 배열 안에 있는지 없는지를 판단해야함
    // 1. for문 돌려서 새로들어온 값이 배열에 있는지 돌려본다 속도 N
    // 2. cnt배열(크기 100)을 만들어서 작업번호를 카운팅한다. 속도 1
    // 2번 방안을 선택하자
    int S,N,i,j,tmp,idx;
    int cnt[100];
    
    scanf("%d %d",&S,&N);
    
    int mem[S];
    
    mem[0] = 0;
    
    for(i = 0; i < N; i++){
        scanf("%d",&tmp);
        
        if(mem[0] != 0){
            for(j = i; j >= 0; j--){
                if(tmp == mem[j])
                    mem[j] = mem[j-1];
                else
                    mem[j+1] = mem[j];
            }
        }else
            printf("!");
        mem[0] = tmp;
    }
    
    for(i = 0; i < S; i++){
        printf("%d",mem[i]);
    }
    return 0;
}
