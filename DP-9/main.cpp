//dy[j] : j무게를 담을 수 있는 가방에 담을 수 있는 보석의 최대가치
//DP문제 이므로 일단 5무게 12가치 보석을 넣었다고 가정하고 시작함.
//문제에서 주어진 가방의 한계치가 11이라면
//dy[j:0~11]로 총 11개의 가방이 있다고 가정한다.이 가방들은 j인덱스 만큼의 무게 허용치를 가진다.
//그 11개의 가방에 5무게 12가치의 보석을 넣어보는 것이다.
//그럼 dy[0~4]에는 못들어가므로 dy[5~11]에 들어갈 것이다.
//그런데 dy[10],dy[11]에는 5무게 12가치의 보석이 각각 두개씩 들어갈 수 있다.
//그러므로 dy[0~4] == 0  , dy[5~9] == 12,  dy[10~11] == 24이렇게 담길 것이다.

//그 다음 3무게 8짜리 보석을 넣는다고 가정해본다.
//3무게 8짜리 보석은 dy[0~2]가방엔 못들어가지면 dy[3~11]가방엔 들어갈 수 있다
//따라서 dy[3~4]==8이 될 것이다. 그 다음부터가 문젠데 나머지 가방엔 이미 5kg짜리 보석이 들어가 있는 것이다.
//예를들어 dy[5]는 최대 허용치가 5kg그램인 가방인데
//여기에 5/12 보석을 넣는게 나을까 3/8보석을 넣는게 나을까? 당연히 5/12이다.
//근데, dy[6]의 경우에는 5/12를 넣는 것보단 3/8보석 두개를 넣는게 더 가치가 크다.

//이런 원리로 0~11kg허용치를 가진 가방들을 만들어 놓고 보석들을 하나하나 넣어보면서
//각 가방이 가질 수 있는 최대 가치를 얻어내는 것이다.
//이때 새로운 보석을 넣었을 때 가치는 dy[j-w]+v이다.
//dy[j-w]는 j만큼의 허용치인 가방에 보석을 넣었다를 의미함
//+v가치를 더해준 것이다.
//결국, dy[j-w]의 값은 w만큼의 보석을 넣었을 때 dy[j-w:3]이라면 dy[3]은 최선의 값이 이미 들어있을 것임
//3보석 하나를 넣은 값이 있겠지?
//거기에 가치 +v를 한 것이 되는 거지
//dy[j-w]+v는 만약 3/8짜리 보석이라고 쳤을 때
//dy[3-3:0] + v == 8 최대 3키로 가방에 3kg보석을 넣어보겠다
//dy[4-3:1] + v == 8 최대 4키로 가방에 3kg보석을 넣어보겠다
//dy[5-3:2] + v == 8 최대 5키로 가방에 3kg보석을 넣어보겟다
//dy[6-3:3] + v == 16이 되는데 최대 6키로 가방에 3kg보석을 넣어보겠다
//dy[3]은 허용치 3kg을 담을 수 있는 가방이므로 3kg짜리 하나를 담는 것이 가장 최선의 선택일 것이다.
//이 것을 이용해서 dy[6]에 대입해본 결과, 5/12 보석 하나를 넣어봤을 대 보다 3/8짜리 보석 두개를 넣는게 더 낫다는 결론이 나온다. 그럼 릴렉스 한다.
//이런식으로 계속 돌리다보면 결국 dy[11](원하고자 하는 가방)이 가질 수 있는 최대 가치를 구할 수 있게 된다.

//한번 더 짚고 넘어가자면
//가방들에 최대 가치들이 하나씩 쌓이게 되면서
//이미 완성된 가방(들어갈 수 있는 최대가치가 이미 들어간)의 값을 이용하여 다른 무게의 가방에 대입할 수 있게 된다.
//예를 들어, dy[3]은 3무게 8가치짜리 보석을 하나 넣는게 가장 최선이다.
//따라서, dy[6]짜리 가방에 원래 있던 값(5/12를 하나 넣은 값) 과
//dy[3]+8 3짜리 가방(이미 3무게 보석이 들어감 이게 최대임) 거기에 3짜리 보석의 가치를 더하여
//두개의 3무게 보석을 dy[6]에 넣어보는 것이다. 최선의 결과 + 새로운 보석 이렇게 되는 것이다.

#include <iostream>
#include <vector>

using namespace std;

int main() {
    ios_base :: sync_with_stdio(false);
    int n, m, w, v;
    cin >> n >> m;
    vector<int> dy(m+1,0);
    
    //읽으면서 바로 계산해도 됌.
    //보석을 순서
    for(int i = 0; i < n; i++){
        cin >> w >> v;
        for(int j = w; j <= m; j++){
            dy[j] = max(dy[j], dy[j-w]+v);
        }
    }
    
    cout << dy[m];
    return 0;
}
/*
4 11
5 12
3 8
6 14
4 8
 */
