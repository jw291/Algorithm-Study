//프로이드 와샬
//그래프에서 모든 정점에서 모든 정점으로 가는 최단거리(최소비용)을 구한다
//다익스트라나 벨만포드는 한 정점에서 다른 정점으로 가는 최단거리
//프로이드 와샬은 "모든 정점"에서 "모든 정점"으로 가는 최단거리임
//1번에서 다른 정점
//2번에서 다른 정점
//.. 이렇게 싹다 구함
//따라서 프로이드 와샬의 dy테이블은 2차원임
//냅색 알고리즘과 동일한 원리의 점화식임

//dy[i][j] i에서 j로 가는 최소비용
//min(dy[i][j],dy[i][k]+dy[k][j]) k는 경유지 i->k + k-j == i->k->j
//초기화 :  만약 i에서 j로 바로 갈 수 없으면 큰 값을 넣어놔야함.
//그다음 i에서 j로 갈 수 있는 모든 경우의 수(중간 경유지 1~N) 중 가장 적은 최소 비용이 최단거리다
//마치 냅색과 같다
//냅색도 일단 가방에 종류1을 다 넣어보고
//그다음 종류2를 다 넣어보고
//모든 종류를 넣어보면서 최소값을 할당한다.

//냅색에서도 알 수 있듯이 동전 1,2가 있고 가방이 3이라면 1,2동전 두개가 들어간 것에 대한 최선의 값이 들어가있다
//i->k-j이러면 K만 지나쳐갔다고 생각할 수 있지만
//플로이드 와샬도 i->2->3-5->j처럼 여러개의 정점을 거쳐 갔다라고 정의가 가능하다.

//만약 i->1->2->j라고 하면 i->2->1->j라고 생각할 수 있다
//만약 5에서 4로 가는데 3을 경유한다고 하면
//dy[5][4] = dy[5][3]+dy[3][4]이다.
//여기서 3을 거쳤다고 했을 때 다이나믹 테이블에 이미 1,2를 거쳐서 3을 간다고 정의되어 있으면
//5->1->2->3->4이 되는데 1->2->3은 순열이다 3->2->1, 2->3->1 뭐든지 될 수 있다.
//제일 좋은 순서대로 되는 것이다. 다이나믹 테이블에 어떤 값이 들어가냐에 따라 다른 것이다. 그래서 다이나믹이다.

//그래서 결과적으로 i-> 1~N or 곧바로 -> j인 값들이 테이블에 모두 relax돼있다.
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    
    int n,m,a,b,c;
    cin >> n >> m;
    vector<vector<int>> dis(n+1,vector<int>(n+1,5000));
    for(int i = 1; i <= n; i++)dis[i][i] = 0; //자기 자신으로 가는건 0
    for(int i = 1; i <= m; i++){
        cin >> a>> b>> c;
        dis[a][b] = c;
    }
    
    for(int k = 1; k <= n; k++) {//1~n가지의 경유지 k를 모두 들린다.
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= n; j++){
                dis[i][j] = min(dis[i][j],dis[i][k]+dis[k][j]);
            }
        }
    }
    
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            if(dis[i][j] == 5000) cout <<"M ";
            else cout << dis[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
/*
5 8
1 2 6
1 3 3
3 2 2
2 4 1
2 5 13
3 4 5
4 2 3
4 5 7

 */
