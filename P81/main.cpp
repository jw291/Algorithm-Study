//벨만포드
//시작 노드와 도착 노드가 있을 때,
//시작노드에서 도착노드까지 도착하려면 한 번에 갈 수있다, 두번에 갈수있다, 세번에 갈수있다.... 가정을 하는 것
//노드가 다섯개 있다면 엣지(경로)가 4개까지가 최대가됌.(모드 노드를 거쳐가는거)
//갔던 곳을 또 가게 된다면? 회로가 발생함 그래서 체크해야함.
//즉 1~n-1개의 경로를 살펴보면서 가장 최단거리를 따짐.

//여기서 한번에 갈 수있다, 두번에 갈수 있다를 따질 때, 한번에 갈수 있는가? 참? 거짓?이 아님
//일단 한번에 갈 수 있는 모든 노드의 비용을 저장하는 것 그리고 배열에 체크
//그 다음 두번에 갈 수 있는 모든 노드의 비용을 저장하는데, 한번에 갈 수 있는 노드에는 비용이 저장되어 있으므로
//그 비용에 + 또 하나의 간선이 두번에 갈 수 있는 간선임
//이런 방식으로 하다보면 시작 노드에서 각 노드로 한번,두번,세번,네번에 갈 수 있는 최단거리가 저장되게됌.

//아주 간단함 어떻게보면 1~n-1번 for문 도는거랑
//min이용하는거만 핵심임

#include <iostream>
#include <vector>
using namespace std;
int dist[101];
struct Edge{
    int s;
    int e;
    int val;
    Edge(int a, int b, int c){
        s = a;
        e = b;
        val = c;
    }
};
int main() {
    vector<Edge> Ed;
    int i, n, m, a, b, c, j ,s ,e;
    scanf("%d %d",&n,&m);
    
    for(i = 1; i <= m; i++){//그래프 생성 인접리스트
        scanf("%d %d %d", &a, &b, &c);
        Ed.push_back(Edge(a,b,c));
    }
    for(i = 1; i <= n; i++){
        dist[i] = 2147000000;
    }
    scanf("%d %d", &s, &e);
    dist[s] = 0;
    
    for(i = 1; i < n; i++){
        //1번부터 n-1번까지의 경로에 따른 비용을 모두 구하면서 적은 값을 dist에 넣음
        //이걸 노드라고 생각하면 안됌.
        //n-1번 루프를 하다보면 dist에 최단거리들이 자동으로 차곡차곡 쌓인다고 생각해야함
        //밑의 독특한 방식의 코드에 의해서
        for(j = 0; j < Ed.size(); j++){
            //위에서 말했듯이, i에 대한 인접노드들을 탐색하는 방식이 아님
            //i루프가 계속 돌다보면 자연스럽게 dist에 최단거리들이 쌓이게됌.
            //예를 들어서, 처음에는 0 무한 무한 무한 무한 이렇게 저장 돼있음
            //dist[1]만 0임
            //따라서, 1에서 2로 가는 값을 더하면 5 < 무한 이 가능함
            //1에서 3로 가는 값 더하면 4 < 무한 이 가능함
            //이제 2에서 3으로 가는 값을 더하려고하는데, 저장되어 있는 dist[2]
            int u = Ed[j].s;
            int v = Ed[j].e;
            int w = Ed[j].val;
            if(dist[u]!=2147000000 && dist[u]+w < dist[v]){ //u:1에서 v:2까지의 비용 < 원래저장된 v까지 비용(이전 경로횟수에서 저장된 값)
                dist[v] = dist[u]+w;
            }
        }
        
        for(i = 1; i <= n; i++){
            printf("%d ",dist[i]);
        }
    }
    for(j = 0; j < Ed.size(); j++){
        int u = Ed[j].s;
        int v = Ed[j].e;
        int w = Ed[j].val;
        if(dist[u]!=2147000000 && dist[u]+w < dist[v]){ //음의 싸이클
            printf("-1\n");
            exit(0);
        }
    }
    //printf("%d\n", dist[e]);
    return 0;
}
/*
5 7
1 2 5
1 3 4
2 3 -3
2 5 13
3 4 5
4 2 3
4 5 7
1 5
 */
